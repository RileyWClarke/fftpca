# -*- coding: utf-8 -*-
"""FFTPCA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RtCC7sHkAdjZs0eHTv-GPIfiT02xbe3K

#FFTPCA
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
import matplotlib.pyplot as plt


#Potentially useful astropy stuff
import astropy
import astropy.io.ascii as ascii
from astropy.table import Table
from astropy.io import fits
from astropy.stats import LombScargle
from astropy.stats import sigma_clipped_stats
from astropy.stats import sigma_clip
from astropy.modeling import powerlaws
from astropy import constants as const
from astropy import units as u

#For reading in and organizing data
import pandas as pd
import requests
import json

#Misc
import scipy
from scipy import stats
from scipy.optimize import curve_fit
from collections import Counter
import itertools
from sklearn.preprocessing import scale
import ipywidgets as widgets
from ipywidgets import interact

#Making Figures look nice
plt.rcParams['font.family'] = 'sans-serif'
plt.rcParams['font.size'] = 12

from google.colab import drive
drive.mount("/content/gdrive")

!pip install LightKurve

"""## Reading in Data

### Short Cadence Data
"""

# read data

data1=np.loadtxt('/content/gdrive/My Drive/BiancoGroup/phot211046195r2_ssc.2m0335.dat')
data2=np.loadtxt('/content/gdrive/My Drive/BiancoGroup/phot210327027r2_ssc.2m0355.dat')

time1,flux1,xx1,yy1=data1[:,0],data1[:,1],data1[:,2],data1[:,3]
time2,flux2,xx1,yy2=data2[:,0],data2[:,1],data2[:,2],data2[:,3]

plt.plot(time1,flux1, c='k')
plt.xlabel('BJD - 2454833 (days)')
plt.ylabel('Flux (e/s)')
plt.title('EPIC 211046195')
plt.savefig('toi1.png', dpi=100, bbox_inches='tight')

plt.plot(time2,flux2, c='k')
plt.xlabel('BJD - 2454833 (days)')
plt.ylabel('Flux (e/s)')
plt.title('EPIC 210327027')
plt.savefig('toi2.png', dpi=100, bbox_inches='tight')

"""### Long Cadence Data"""

bjds = np.load('gdrive/My Drive/BiancoGroup/bjds.npy')
fluxes = np.load('gdrive/My Drive/BiancoGroup/fluxes.npy')
fluxerrs = np.load('gdrive/My Drive/BiancoGroup/fluxerrs.npy')

fig, axes = plt.subplots(9, figsize=(10,45))
p = 0
for i in range(0,900,100):
  #fluxes[i] = (fluxes[i] - np.nanmean(fluxes[i])) / np.nanstd(fluxes[i])
  axes[p].plot(bjds[i], fluxes[i], c='k')
  axes[p].set_ylabel('Flux')
  axes[p].set_xlabel('BJD - 2454833 (days)')
  p += 1

"""# FFT Filtering"""

def invgaussian(a ,m, s, x):
    g = -a * np.exp(-(m-x)**2 / s**2) + 1 
    return g

def bandpass_ifft(t, flux, low_cutoff, high_cutoff, sample=1, 
                  M=None, inv_box=False, gf_sig = 1, Filter='box', Plot=''):
    """Bandpass filtering on a real signal using inverse FFT
    
    Inputs
    =======
    
    X: 1-D numpy array of floats, the real time domain signal (time series) to be filtered
    Low_cutoff: float, frequency components below this frequency will not pass the filter (physical frequency in unit of Hz)
    High_cutoff: float, frequency components above this frequency will not pass the filter (physical frequency in unit of Hz)
    sample: float, the sampling frequency of the signal (physical frequency in unit of Hz)    
    M: idk lmao
    inv_box: If using box filter, setting inv=True filters out frequencies outside the box
    Filter: Default filter is box, can choose 'Gaussian' also
    
    Notes
    =====
    1. The input signal must be real, not imaginary nor complex
    2. The Filtered_signal will have only half of original amplitude. Use abs() to restore. 
    3. In Numpy/Scipy, the frequencies goes from 0 to F_sample/2 and then from negative F_sample to 0. 
    
    """        
    #perform fft
    spectrum = np.fft.rfft(flux) 
    freq = np.fft.rfftfreq(len(flux), sample)
    freq_sort = np.sort(spectrum)
    
    #calculate the index of the cut off points
    lc = np.abs(freq) < Low_cutoff
    hc = np.abs(freq) > High_cutoff
    between = ~(lc + hc)
    
    ps = np.abs(spectrum)**2
    if ('PS' in Plot) or ('All' in Plot):
      plt.plot(freq, ps)
      plt.title("power spectrum")
      plt.xlabel('Frequency (1/day)')
      plt.ylabel('Power Spectral Density')
      #plt.xlim(0,100)
      #plt.savefig('Figures/spec.png', bbox_inches='tight', pad_inches=0.5)
      plt.show()

    if ('DFT' in Plot) or ('All' in Plot):
      plt.plot(freq, spectrum)
      #plt.plot(freq[between], spectrum[between], alpha=0.5)
      plt.title("real fourier transform ")
      plt.xlabel('Frequency (1/day)')
      plt.ylabel('Amplitude')
      #plt.xlim(0,100)
      #plt.savefig('Figures/fft.png', bbox_inches='tight', pad_inches=0.5)
      plt.show()
    
    
    
    if Filter == 'box':
    
      #filtered_spectrum = spectrum.copy()
    
      if inv_box == True:
        x_1 = np.arange(0, Low_cutoff, 0.1)
        x_2 = np.arange(High_cutoff, np.max(freq), 0.1)
        plt.plot(freq, spectrum)
        plt.fill_between(x_1, [plt.ylim()[0]] * len(x_1), 
                     [plt.ylim()[1]] * len(x_1), color='r', alpha=0.3)
        plt.fill_between(x_2, [plt.ylim()[0]] * len(x_2), 
                     [plt.ylim()[1]] * len(x_2), color='r', alpha=0.3)
        plt.title("range to suppress")
        plt.figure()
        filtered_spectrum[lc] = 0.
        filtered_spectrum[hc] = 0.
      else:
        x_ = np.arange(Low_cutoff, High_cutoff, 0.1)
        plt.plot(freq, spectrum)
        plt.fill_between(x_, [plt.ylim()[0]] * len(x_), 
                     [plt.ylim()[1]] * len(x_), color='r', alpha=0.3)
        plt.title("range to suppress")
        plt.figure()
        filtered_spectrum[between] = 0.
    
    if Filter == 'Gaussian':
      ig = invgaussian(1, np.median([low_cutoff,high_cutoff]), gf_sig, freq)
      filtered_spectrum = spectrum * ig
      if ('filter' in Plot) or ('All' in Plot):
        plt.plot(freq, ig)
        plt.title('Gaussian Filter')
        #plt.savefig('Figures/gfilter.png')
        #plt.xlim(0,100)
        plt.figure()

    if ('spec_filtered' in Plot) or ('All' in Plot):
      plt.plot(freq, filtered_spectrum, label="filtered spectrum")
      plt.plot(freq, spectrum, c='k', ls="--", label="spectrum", alpha=0.5)
      plt.title("Unfiltered vs. Filtered Spectrum")
      plt.xlabel('Frequency (1/day)')
      plt.ylabel('Amplitude')
      ldg = plt.legend(fontsize=12)
      #plt.xlim(0,100)
      #plt.savefig('Figures/filter_compare.png', bbox_inches='tight', pad_inches=0.5)
      plt.figure()

    filtered_signal = np.fft.irfft(filtered_spectrum)  # Construct filtered signal

    if ('signal_filtered' in Plot) or ('All' in Plot):
      fig = plt.figure(figsize=(15,10)) 
      plt.plot(t, filtered_signal, label="filtered signal")
      plt.plot(t, flux, c='k', ls="--", label="original signal", alpha=0.5)
      plt.xlabel('Time')
      plt.ylabel('Amplitude')
      plt.title("Unfiltered vs. Filtered Signal")
      #plt.savefig('Figures/filtered_signal.png', bbox_inches='tight', pad_inches=0.5)
      plt.legend()
      #Filtered_signal = np.zeros_like(Filtered_signal)
    return spectrum, freq, filtered_spectrum, filtered_signal, Low_cutoff, High_cutoff

dfts = []
pspectra = []
for i, flux in enumerate(fluxes):
  Low_cutoff, High_cutoff, F_sample = 4, 6, np.diff(bjds[i])[0]
  Spectrum, frequency, Filtered_spectrum, Filtered_signal, Low_freq, High_freq = bandpass_ifft(bjds[i], flux, Low_cutoff, High_cutoff, 
                          F_sample, gf_sig = 1, Filter='Gaussian')

  dfts.append(Spectrum)
  pspectra.append(np.abs(Spectrum)**2)

"""## Short Cadence FFT Filtering"""

flux1norm = flux1 / sigma_clip(flux1, sigma=3).mean()

flux2norm = flux2 / sigma_clip(flux2, sigma=3).mean()

Low_cutoff, High_cutoff, F_sample = 4.0, 4.2, np.diff(time1)[0]
Spectrum1, frequency1, Filtered_spectrum1, Filtered_signal1, Low_freq, High_freq = bandpass_ifft(time1, flux1norm, Low_cutoff, High_cutoff, 
                          F_sample, gf_sig = 0.1, Filter='Gaussian')

Low_cutoff, High_cutoff, F_sample = 4.0, 4.2, np.diff(time2)[0]
Spectrum2, frequency2, Filtered_spectrum2, Filtered_signal2, Low_freq, High_freq = bandpass_ifft(time2, flux2norm, Low_cutoff, High_cutoff, 
                          F_sample, gf_sig = 0.1, Filter='Gaussian')

plt.plot(frequency1[1:],np.abs(Spectrum1[1:])**2)
plt.xlabel('Frequency')
plt.text(10.2, plt.ylim()[1]/2, 'Amplitude', rotation=-90, va='center')
plt.yticks([])
plt.title('EPIC 211046195')
plt.xlim(0,10);

plt.plot(frequency1[1:],np.abs(Spectrum1[1:])**2, label='Original')
plt.plot(frequency1[1:],np.abs(Filtered_spectrum1[1:])**2, label='Filtered')
plt.xlabel('Frequency')
plt.ylabel('Amplitude')
plt.title('EPIC 211046195')
plt.legend()
plt.xlim(0,10);

plt.plot(frequency1[1:],np.abs(Spectrum1[1:])**2, label='Original')
plt.plot(frequency1[1:],np.abs(Filtered_spectrum1[1:])**2, label='Filtered')
plt.vlines(2.356,0,200000)
plt.xlabel('Frequency')
plt.ylabel('Amplitude')
plt.title('EPIC 211046195')
plt.legend()
plt.xlim(2.1,2.5);

fig = plt.figure(figsize=(10,5))

  res = flux1norm - Filtered_signal1

  left, width = 0.1, 0.65
  bottom, height = 0.1, 0.65

  rect_scatter = [left, bottom + 0.2, width, height]
  rect_histx = [left, bottom, width, 0.2]
  plt.subplots_adjust(hspace=0., wspace=0.1)
  ax1 = plt.axes(rect_scatter)
  axres = plt.axes(rect_histx)
  ax1.minorticks_on()
  axres.minorticks_on()
  plt.setp(ax1.get_xticklabels(),
            visible=False)

  ax1.errorbar(time1, flux1norm, color='SteelBlue', alpha=1,
                                 marker='.', fmt='.', label='Original')
  ax1.errorbar(time1, Filtered_signal1,
                                 color='DarkOrange', alpha=0.25,
                                 marker='.', fmt='.', label='Filtered')
  ax1.set_ylabel('Standarized Flux')
  ax1.legend(fontsize=12)

  axres.plot(time1, res, color='k', alpha=0.5)
  axres.set_ylabel('Residuals')

  ax1.set_xlim(time1[0], 2265)
  #ax1.set_ylim(-2,2)
  axres.set_xlim(time1[0], 2265)
  #axres.set_ylim(-0.5,0.5)

plt.savefig('resids.png', dpi=100, bbox_inches='tight');

s = pd.Series(Filtered_signal1)
window=1000
sroll = s.rolling(window, center=True).median()
plt.plot(time1, Filtered_signal1, label='Post-FFT')
plt.plot(time1, sroll.values, label='{} pt rollmed'.format(window))
plt.xlabel('Time')
plt.ylabel('Flux')
plt.legend();

s = pd.Series(Filtered_signal1)
window=120
sroll = s.rolling(window, center=True).median()
plt.plot(time1, Filtered_signal1, label='Post-FFT')
plt.plot(time1, sroll.values, label='{} pt rollmed'.format(window))
plt.xlabel('Time')
plt.ylabel('Flux')
plt.xlim(2260,2270)
plt.ylim(0.8,1.2)
plt.legend();

import lightkurve as lk

P = 2.356**(-1)
lc = lk.LightCurve(time1, Filtered_signal1 - sroll.values)
fold = lc.fold(P, t0 = 0)
fold.scatter()
plt.title('P = {0:.3f} d'.format(P));

plt.plot(frequency2[1:],np.abs(Spectrum2[1:])**2, c='k')
plt.xlabel('Frequency')
plt.ylabel('Amplitude')
plt.title('EPIC 210327027 PS')
plt.xlim(0,10)
plt.savefig('toi2ps.png', dpi=100, bbox_inches='tight')

plt.plot(frequency2[1:],np.abs(Spectrum2[1:])**2, label='Original')
plt.plot(frequency2[1:],np.abs(Filtered_spectrum2[1:])**2, label='Filtered')
plt.xlabel('Frequency')
plt.ylabel('Amplitude')
plt.title('EPIC 211046195')
plt.legend(fontsize=12)
plt.xlim(0,10);

plt.plot(time2,flux2norm, label='Original')
plt.plot(time2[1:],Filtered_signal2,alpha=0.5, label='Filtered')
plt.xlabel('BJD - 2454833 (days)')
plt.ylabel('Standardized Flux (e/s)')
plt.title('EPIC 211046195')
plt.savefig('toi2_filtered.png', dpi=100, bbox_inches='tight')
plt.legend(fontsize=12);

@interact
def residplot(windowcenter = widgets.FloatSlider(min=2220, max=2300, step=0.1, value=np.median(time2)), 
              windowsize = widgets.FloatSlider(min=0.1, max=70, step=0.1, value=70)):

  fig = plt.figure(figsize=(10,5))

  res = flux2norm[1:] - Filtered_signal2

  left, width = 0.1, 0.65
  bottom, height = 0.1, 0.65
  #bottom_h = left_h = left + width

  rect_scatter = [left, bottom + 0.2, width, height]
  rect_histx = [left, bottom, width, 0.2]
  #    rect_histy = [left_h, bottom, 0.2, height]
  plt.subplots_adjust(hspace=0., wspace=0.1)
  ax1 = plt.axes(rect_scatter)
  axres = plt.axes(rect_histx)
  ax1.minorticks_on()
  axres.minorticks_on()
  plt.setp(ax1.get_xticklabels(),
            visible=False)

  ax1.errorbar(time2, flux2norm, color='SteelBlue', alpha=1,
                                 marker='.', fmt='.', label='Original')
  ax1.errorbar(time2[1:], Filtered_signal2,
                                 color='DarkOrange', alpha=0.25,
                                 marker='.', fmt='.', label='Filtered')
  ax1.set_ylabel('Standarized Flux')
  ax1.legend(fontsize=12)

  axres.errorbar(time2[1:], res, yerr=None, color='k',
                               alpha=0.1, fmt='.')

  axres.ticklabel_format(axis="y", style="sci")
  axres.set_xlabel('BJD - 2454833 (days)')
  axres.set_ylabel('Residuals')

  ax1.set_xlim(windowcenter - (windowsize/2), windowcenter + (windowsize/2))
  #ax1.set_ylim(-2,2)
  axres.set_xlim(windowcenter - (windowsize/2), windowcenter + (windowsize/2))
  #axres.set_ylim(-0.5,0.5)

fig, ax = plt.subplots(2,2, figsize=(10,10))

ax[0,0].plot(time1,flux1norm, c='k')
ax[1,0].plot(time2,flux2norm, c='k')
ax[0,1].plot(frequency1[1:],np.abs(Spectrum1[1:])**2, c='k')
ax[1,1].plot(frequency2[1:],np.abs(Spectrum2[1:])**2, c='k')

ax[0,0].set_xlabel('BJD - 2454833 (days)', fontsize = 12)
ax[0,1].set_xlabel('Frequency (1/day)', fontsize = 12)
ax[1,0].set_xlabel('BJD - 2454833 (days)', fontsize = 12)
ax[1,1].set_xlabel('Frequency (1/day)', fontsize = 12)

ax[0,0].set_ylabel('Normalized Flux', fontsize = 12)
ax[1,0].set_ylabel('Normalized Flux', fontsize = 12)

ax[0,1].text(10, ax[0,1].set_ylim()[1]/2, 'Amplitude', va='center', fontsize = 12, rotation=-90)
ax[1,1].text(10, ax[1,1].set_ylim()[1]/2, 'Amplitude', va='center', fontsize = 12, rotation=-90)

ax[0,1].set_xlim(0,10)
ax[1,1].set_xlim(0,10)

ax[0,1].set_yticks([])
ax[1,1].set_yticks([])

#ax[0,0].vlines(time1[0],0.75,1.25, color='r')
#ax[0,0].vlines(time1[10000],0.75,1.25, color='r')
#ax[0,0].hlines(1.25, time1[0], time1[10000], color='r')
#ax[0,0].hlines(0.75, time1[0], time1[10000], color='r')

subax1 = plt.axes([0.27, 0.77, .2, .1])
subax1.plot(time1[0:100],flux1norm[0:100], color='k')
subax1.get_xaxis().set_ticks([])
subax1.get_yaxis().set_ticks([])

subax2 = plt.axes([0.27, 0.36, .2, .1])
subax2.plot(time2[0:100],flux2norm[0:100], color='k')
subax2.get_xaxis().set_ticks([])
subax2.get_yaxis().set_ticks([]);


plt.savefig('4plot.png', dpi=100, bbox_inches='tight')

fig, ax = plt.subplots(1,2, figsize=(10,5))

ax[0].plot(time1,flux1norm, c='k')
ax[1].plot(frequency1[1:],np.abs(Spectrum1[1:])**2, c='k')

ax[0].set_xlabel('BJD - 2454833 (days)', fontsize = 12)
ax[1].set_xlabel('Frequency (1/day)', fontsize = 12)
ax[0].set_ylabel('Normalized Flux', fontsize = 12)

ax[1].text(10, ax[1].set_ylim()[1]/2, 'Amplitude', va='center', fontsize = 12, rotation=-90)

ax[1].set_xlim(0,10)

ax[1].set_yticks([])

subax1 = plt.axes([0.15, 0.67, .2, .2])
subax1.plot(time1[0:100],flux1norm[0:100], color='k')
subax1.get_yaxis().set_ticks([])
subax1.ticklabel_format(useOffset=False)
subax1.tick_params(axis='both', labelsize=8)




plt.savefig('2plot.png', dpi=100, bbox_inches='tight')

"""# PCA with Spectra"""

from sklearn.decomposition import PCA

pspec_dict = {}


for j, spec in enumerate(pspectra):
  pspec_dict["spec{0}".format(j)] = spec

pspec_df = pd.DataFrame(data=pspec_dict)

pspec_df.head()

for i in range(5):
  plt.plot(frequency, pspec_df.values[:,i], c='k')
  plt.show()

'''
### Remove first values from PS:
pspec_df = pspec_df.drop([0,1,2,3,4])
pspec_df.head()
'''

pspec_df.shape

x = pspec_df.values
x = scale(x, axis=0)

pca = PCA()

pca.fit(x)

X = pca.transform(x)

pca_df = pd.DataFrame(data = X)
print(pca_df.shape)
pca_df.head()

pca_df.to_csv("/content/gdrive/My Drive/BiancoGroup/pcaLongTermCadenceK2.csv")

fig, axes = plt.subplots(5, figsize=(10,20), sharex=True)
p = 0
for i in range(5):
  axes[p].plot(frequency[5:],pca_df[i][5:], c='k', alpha=0.8)
  axes[p].set_ylabel('Amplitude')
  p += 1
axes[0].arrow(4.09, 100, 0, -40, width=0.2, head_length=5, color='red')
plt.xlabel('Frequency (1/day)')
plt.subplots_adjust(hspace=0)
plt.savefig('pspcs.png', dpi=100, bbox_inches='tight')

frequency[5:][np.where(pca_df[0][5:] == pca_df[0][75:].max())[0]]

a = np.arange(0,len(x[0]))
plt.scatter(a, np.cumsum(pca.explained_variance_ratio_), c='k', marker='.')
plt.plot(a, np.full(len(x[0]),0.95),'k--')
plt.xlabel('number of components')
plt.ylabel('cumulative explained variance')
plt.title('PS Explained Var')
plt.savefig('expvar.png', bbox_inches='tight')

"""## Method 1: Removing First 2 Components entirely"""

nComp = 200
Xhat = np.dot(pca.transform(x)[:,2:nComp], pca.components_[2:nComp,:])

fig, axes = plt.subplots(2,1,figsize = (10,5))
axes[0].plot(frequency,x[:,0])
axes[1].plot(frequency, Xhat[:,0])
#axes[0].set_ylim(-4,6)
#axes[1].set_ylim(-4,6)


axes[0].set_title('Original (top) vs reverse-PCA (bottom)')
plt.xlabel('Frequency (1/day)')
plt.savefig('pca_compare.png', dpi=100, bbox_inches='tight')

plt.plot(frequency,x[:,0], alpha=0.5)
plt.plot(frequency, Xhat[:,0]);

"""## Method 2: Bandpass Filtering First 2 Components"""

a, b, c, d = np.polyfit(frequency[5:], pca_df[0][5:], deg=3)

fit = a * frequency[5:]**3 + b * frequency[5:]**2 + c * frequency[5:] + d

plt.plot(frequency[5:], pca_df[0][5:])
plt.plot(frequency[5:], fit)
plt.xlabel('Frequency (1/day)')
plt.savefig('PC1_fit.png', dpi=100, bbox_inches='tight')

def gaussian(a, m, s, x):
    g = a * np.exp(-(m-x)**2 / s**2) 
    return g

def hrm_gfilter(x, s, fund, nhrm=0, amps=np.ones(len(x))):

  fhrms = np.array([fund])

  for i in range(2, nhrm+2):
    fhrms = np.append(fhrms, i*fund)

  filt = np.ones(len(x))

  for hrm, amp in zip(fhrms, amps):
    filt *= invgaussian(amp,hrm,s,x) 
   # filt += gaussian(amp,hrm,s,x)

  return filt

filt = hrm_gfilter(frequency, 0.2, 4.1, 2)

plt.plot(frequency, filt)
plt.ylim(-0.1,1.1);

###Bandpass filtering:

#Some params:
fstep = np.diff(frequency).mean()
fund = 4.1
nhrms = 2
std = 0.2
pts_per_std = int(std/fstep)

pc1 = np.copy(pca_df[0])#to avoid overwriting

#Make array of fund & harmonic indices:
hrm_inds = []

for i in range(1,nhrms+2):
  hrm_inds.append(np.where(np.abs(frequency - fund*i) == np.abs(frequency - fund*i).min())[0][0])


#For each index, calculate local avg, subtract, filter, add avg back:
for k, ind in enumerate(hrm_inds):
  local_avg = np.mean(np.concatenate((pc1[(ind - pts_per_std*2):(ind - pts_per_std*1)], 
                       pc1[(ind + pts_per_std*1):(ind + pts_per_std*2)])))

  pc1[5:] -= local_avg
  pc1[5:] *= hrm_gfilter(frequency[5:], std, fund*(k+1))
  pc1[5:] += local_avg

#Plotting:
fig, ax = plt.subplots(1,2, figsize=(10,5))
ax[0].plot(frequency[5:], pca_df[0][5:], label='Original')
ax[0].plot(frequency[5:], pc1[5:], label='Filtered')
ax[0].vlines(3.5,-10,50, color='grey', ls='--')
ax[0].vlines(5.5,-10,50, color='grey', ls='--')
ax[0].hlines(50,3.5,5.5, color='grey', ls='--')
ax[0].hlines(-10,3.5,5.5, color='grey', ls='--')
ax[1].plot(frequency[5:], pca_df[0][5:], label='Original')
ax[1].plot(frequency[5:], pc1[5:], label='Filtered')
ax[0].set_xlabel('Frequency (1/day)')
ax[1].set_xlabel('Frequency (1/day)')
ax[0].set_ylabel('Amplitude')
ax[1].set_xlim(3.5,5.5)
ax[1].set_ylim(-10,50)
ax[0].legend()
ax[1].legend()
plt.savefig('pc1filter.png', dpi=100, bbox_inches='tight');

fstep = np.diff(frequency).mean()
fund = 4.1
nhrms = 2
std = 0.2
pts_per_std = int(std/fstep)
pc2 = np.copy(pca_df[1])  

hrm_inds = []

for i in range(1,nhrms+2):
  hrm_inds.append(np.where(np.abs(frequency - fund*i) == np.abs(frequency - fund*i).min())[0][0])


for k, ind in enumerate(hrm_inds):
  local_avg = np.mean(np.concatenate((pc2[(ind - pts_per_std*2):(ind - pts_per_std*1)], 
                       pc2[(ind + pts_per_std*1):(ind + pts_per_std*2)])))

  pc2[5:] -= local_avg
  pc2[5:] *= hrm_gfilter(frequency[5:], std, fund*(k+1))
  pc2[5:] += local_avg

fig, ax = plt.subplots(1,2, figsize=(10,5))
ax[0].plot(frequency[5:], pca_df[1][5:], label='Original')
ax[0].plot(frequency[5:], pc2[5:], label='Filtered')
ax[0].vlines(3.5,-10,40, color='grey', ls='--')
ax[0].vlines(5.5,-10,40, color='grey', ls='--')
ax[0].hlines(40,3.5,5.5, color='grey', ls='--')
ax[0].hlines(-10,3.5,5.5, color='grey', ls='--')
ax[1].plot(frequency[5:], pca_df[1][5:], label='Original')
ax[1].plot(frequency[5:], pc2[5:], label='Filtered')
ax[1].set_xlim(3.5,5.5)
ax[1].set_ylim(-10,40)
ax[0].legend()
ax[1].legend();

fig, ax = plt.subplots(2,2, figsize=(10,10))

ax[0,0].plot(frequency[5:], pca_df[0][5:], label='PC1 Original')
ax[0,0].plot(frequency[5:], pc1[5:], label='PC1 Filtered')
ax[0,0].vlines(3.5,-10,50, color='grey', ls='--')
ax[0,0].vlines(5.5,-10,50, color='grey', ls='--')
ax[0,0].hlines(50,3.5,5.5, color='grey', ls='--')
ax[0,0].hlines(-10,3.5,5.5, color='grey', ls='--')
ax[0,1].plot(frequency[5:], pca_df[0][5:], label='PC1 Original')
ax[0,1].plot(frequency[5:], pc1[5:], label='PC1 Filtered')
ax[0,0].set_xlabel('Frequency (1/day)')
ax[0,1].set_xlabel('Frequency (1/day)')
ax[0,0].set_ylabel('Amplitude')
ax[0,1].set_xlim(3.5,5.5)
ax[0,1].set_ylim(-10,50)
ax[0,0].legend()
ax[0,1].legend()

ax[1,0].plot(frequency[5:], pca_df[1][5:], label='PC2 Original')
ax[1,0].plot(frequency[5:], pc2[5:], label='PC2 Filtered')
ax[1,0].vlines(3.5,-10,40, color='grey', ls='--')
ax[1,0].vlines(5.5,-10,40, color='grey', ls='--')
ax[1,0].hlines(40,3.5,5.5, color='grey', ls='--')
ax[1,0].hlines(-10,3.5,5.5, color='grey', ls='--')
ax[1,1].plot(frequency[5:], pca_df[1][5:], label='PC2 Original')
ax[1,1].plot(frequency[5:], pc2[5:], label='PC2 Filtered')
ax[1,0].set_xlabel('Frequency (1/day)')
ax[1,1].set_xlabel('Frequency (1/day)')
ax[1,0].set_ylabel('Amplitude')
ax[1,1].set_xlim(3.5,5.5)
ax[1,1].set_ylim(-10,40)
ax[1,0].legend()
ax[1,1].legend()
plt.savefig('pcfilter.png', dpi=100, bbox_inches='tight');

t = np.array([pc1,pc2])
filtered_transform = pca.transform(x).copy()
print(t.T.shape, filtered_transform[:,0:2].shape)
filtered_transform[:,0:2] = t.T

Xhat1 = np.dot(filtered_transform[:,0:nComp], pca.components_[0:nComp,:])

fig, axes = plt.subplots(2,1,figsize = (10,5))
axes[0].plot(frequency,x[:,0])
axes[1].plot(frequency,Xhat1[:,0])
#axes[0].set_ylim(-5,7)
#axes[1].set_ylim(-5,7)


axes[0].set_title('Original (top) vs reverse-PCA (bottom)')
plt.xlabel('Frequency (1/day)');

# Multiple box plots on one Axes
fig, ax = plt.subplots()
ax.boxplot([pca.components_[0], pca.components_[1], pca.components_[2], pca.components_[3],pca.components_[4]])
plt.hlines(0, 0, 7, linestyle='--', alpha=0.5)
plt.xlabel('Component #')
plt.title('Distribution of Principal Component Coefficients')
plt.xlim(0.5,5.5)
plt.savefig('box.png', dpi=100, bbox_inches='tight')
plt.show()

"""# PCA with DFTs"""

dft_dict = {}


for j, dft in enumerate(dfts):
  dft_dict["dft{0}".format(j)] = dft

dft_df = pd.DataFrame(data=dft_dict)

y = dft_df.values
y.real = scale(y.real, axis=0)
y.imag = scale(y.imag, axis=0)

print(y[:,0].real.mean(), y[:,0].imag.mean())

print(y[:,0].real.std(), y[:,0].imag.std())

pca.fit(y.real)

Y = pca.transform(y.real)

pca2_df = pd.DataFrame(data = Y)
print(pca2_df.shape)
pca2_df.head()

for i in range(0,10):
  plt.plot(frequency,pca2_df[i], 'k')
  plt.title('Principal Component {}'.format(i+1))
  plt.xlabel('Frequency (1/day)')
  plt.show()

a = np.arange(len(y[0]))
plt.scatter(a, np.cumsum(pca.explained_variance_ratio_), c='k', marker='.')
plt.plot(a, np.full(len(a),0.95),'k--')
plt.xlabel('number of components')
plt.ylabel('cumulative explained variance')
plt.title('DFT Explained Var')
plt.savefig('expvar2.png', bbox_inches='tight')

# Multiple box plots on one Axes
fig, ax = plt.subplots()
ax.boxplot([pca.components_[0], pca.components_[1], pca.components_[2], pca.components_[3],pca.components_[4]])
plt.xlabel('Component #')
plt.title('DFT Components')
plt.savefig('box2.png', dpi=100, bbox_inches='tight')
plt.show()

"""## Removing 1st Component"""

nComp = 400
Yhat = np.dot(pca.transform(y.real)[:,2:nComp], pca.components_[2:nComp,:])

fig, axes = plt.subplots(2,1,figsize = (10,5))
axes[0].plot(frequency,y[:,0])
axes[1].plot(frequency, Yhat[:,0])
#axes[0].set_ylim(-4,6)
#axes[1].set_ylim(-4,6)


axes[0].set_title('Original DFT (top) vs reverse-PCA DFT (bottom)')
plt.xlabel('Frequency (1/day)')
plt.savefig('pca2_compare.png', dpi=100, bbox_inches='tight')

plt.plot(frequency,y[:,0])
plt.plot(frequency, Yhat[:,0],alpha=0.5)
plt.xlabel('Frequency (1/day)');

Yhatc = Yhat + (1j)*y.imag

for i in range(0,900,100):
  plt.plot(bjds[i][1:],np.fft.irfft(y[:,i]), label='Original')
  plt.plot(bjds[i][1:],np.fft.irfft(Yhatc[:,i]), alpha=0.5, label='PCA-Filtered')
  plt.xlabel('BJD - 2454833 (days)')
  plt.ylabel('Standardized Flux')
  plt.legend(fontsize=12)
  plt.show()

"""## Bandpass Filtering 1st Component"""

fstep = np.diff(frequency).mean()
fund = 4.04
nhrms = 2
std = 0.1
pts_per_std = int(std/fstep)
dftpc1 = np.copy(pca2_df[0])  

hrm_inds = []

for i in range(1,nhrms+2):
  hrm_inds.append(np.where(np.abs(frequency - fund*i) == np.abs(frequency - fund*i).min())[0][0])


for k, ind in enumerate(hrm_inds):
  local_avg = np.mean(np.concatenate((dftpc1[(ind - pts_per_std*2):(ind - pts_per_std*1)], 
                       dftpc1[(ind + pts_per_std*1):(ind + pts_per_std*2)])))

  dftpc1[5:] -= local_avg
  dftpc1[5:] *= hrm_gfilter(frequency[5:], std, fund*(k+1))
  dftpc1[5:] += local_avg

fig, ax = plt.subplots(1,2, figsize=(10,5))
ax[0].plot(frequency[5:], pca2_df[0][5:], label='Original')
ax[0].plot(frequency[5:], dftpc1[5:], label='Filtered')
ax[0].vlines(3.5,-10,50, color='grey', ls='--')
ax[0].vlines(5.5,-10,50, color='grey', ls='--')
ax[0].hlines(50,3.5,5.5, color='grey', ls='--')
ax[0].hlines(-10,3.5,5.5, color='grey', ls='--')
ax[1].plot(frequency[5:], pca2_df[0][5:], label='Original')
ax[1].plot(frequency[5:], dftpc1[5:], label='Filtered')
ax[1].set_xlim(3.5,5.5)
ax[1].set_ylim(-10,50)
ax[0].legend()
ax[1].legend();

fstep = np.diff(frequency).mean()
fund = 4.1
nhrms = 2
std = 0.1
pts_per_std = int(std/fstep)
dftpc2 = np.copy(pca2_df[1])  

hrm_inds = []

for i in range(1,nhrms+2):
  hrm_inds.append(np.where(np.abs(frequency - fund*i) == np.abs(frequency - fund*i).min())[0][0])


for k, ind in enumerate(hrm_inds):
  local_avg = np.mean(np.concatenate((dftpc2[(ind - pts_per_std*2):(ind - pts_per_std*1)], 
                       dftpc2[(ind + pts_per_std*1):(ind + pts_per_std*2)])))

  dftpc2[5:] -= local_avg
  dftpc2[5:] *= hrm_gfilter(frequency[5:], std, fund*(k+1))
  dftpc2[5:] += local_avg

fig, ax = plt.subplots(1,2, figsize=(10,5))
ax[0].plot(frequency[5:], pca2_df[1][5:], label='Original')
ax[0].plot(frequency[5:], dftpc2[5:], label='Filtered')
ax[0].vlines(3.5,-10,50, color='grey', ls='--')
ax[0].vlines(5.5,-10,50, color='grey', ls='--')
ax[0].hlines(50,3.5,5.5, color='grey', ls='--')
ax[0].hlines(-10,3.5,5.5, color='grey', ls='--')
ax[1].plot(frequency[5:], pca2_df[1][5:], label='Original')
ax[1].plot(frequency[5:], dftpc2[5:], label='Filtered')
ax[1].set_xlim(3.5,5.5)
ax[1].set_ylim(-10,50)
ax[0].legend()
ax[1].legend();

t = np.array([dftpc1, dftpc2])
filtered_transform2 = pca.transform(y.real).copy()
print(t.T.shape, filtered_transform2[:,0:2].shape)
filtered_transform2[:,0:2] = t.T

nComp=400

Yhat1 = np.dot(filtered_transform2[:,0:nComp], pca.components_[0:nComp,:])

fig, axes = plt.subplots(2,1,figsize = (10,5))
axes[0].plot(frequency,y[:,0])
axes[1].plot(frequency, Yhat1[:,0])
#axes[0].set_ylim(-5,7)
#axes[1].set_ylim(-5,7)


axes[0].set_title('Original (top) vs reverse-PCA (bottom)')
plt.xlabel('Frequency (1/day)')
plt.savefig('dftcompare.png', dpi=100, bbox_inches='tight')

Yhat1c = Yhat1 + (1j)*y.imag

fig, axes = plt.subplots(5,2, figsize=(10,20), sharex=True)

axes[0,0].plot(bjds[0][1:],np.fft.irfft(y[:,0]), label='Original')
axes[0,0].plot(bjds[0][1:],np.fft.irfft(Yhat1c[:,0]), alpha=0.5, label='PCA-Filtered')
axes[0,0].set_ylabel('Standardized Flux', fontsize=12)
axes[0,0].legend(fontsize=12)

axes[1,0].plot(bjds[100][1:],np.fft.irfft(y[:,100]), label='Original')
axes[1,0].plot(bjds[100][1:],np.fft.irfft(Yhat1c[:,100]), alpha=0.5, label='PCA-Filtered')
axes[1,0].set_ylabel('Standardized Flux', fontsize=12)
axes[1,0].legend(fontsize=12)

axes[2,0].plot(bjds[200][1:],np.fft.irfft(y[:,200]), label='Original')
axes[2,0].plot(bjds[200][1:],np.fft.irfft(Yhat1c[:,200]), alpha=0.5, label='PCA-Filtered')
axes[2,0].set_ylabel('Standardized Flux', fontsize=12)
axes[2,0].legend(fontsize=12)

axes[3,0].plot(bjds[300][1:],np.fft.irfft(y[:,300]), label='Original')
axes[3,0].plot(bjds[300][1:],np.fft.irfft(Yhat1c[:,300]), alpha=0.5, label='PCA-Filtered')
axes[3,0].set_ylabel('Standardized Flux', fontsize=12)
axes[3,0].legend(fontsize=12)

axes[4,0].plot(bjds[400][1:],np.fft.irfft(y[:,400]), label='Original')
axes[4,0].plot(bjds[400][1:],np.fft.irfft(Yhat1c[:,400]), alpha=0.5, label='PCA-Filtered')
axes[4,0].set_ylabel('Standardized Flux', fontsize=12)
axes[4,0].set_xlabel('BJD - 2454833 (days)', fontsize=12)
axes[4,0].legend(fontsize=12)

axes[0,1].plot(bjds[500][1:],np.fft.irfft(y[:,500]), label='Original')
axes[0,1].plot(bjds[500][1:],np.fft.irfft(Yhat1c[:,500]), alpha=0.5, label='PCA-Filtered')
axes[0,1].yaxis.tick_right()
axes[0,1].yaxis.set_label_position("right")
axes[0,1].set_ylabel('Standardized Flux', rotation=-90, fontsize=12)
axes[0,1].legend(fontsize=12)

axes[1,1].plot(bjds[600][1:],np.fft.irfft(y[:,600]), label='Original')
axes[1,1].plot(bjds[600][1:],np.fft.irfft(Yhat1c[:,600]), alpha=0.5, label='PCA-Filtered')
axes[1,1].yaxis.tick_right()
axes[1,1].yaxis.set_label_position("right")
axes[1,1].set_ylabel('Standardized Flux', rotation=-90, fontsize=12)
axes[1,1].legend(fontsize=12)

axes[2,1].plot(bjds[700][1:],np.fft.irfft(y[:,700]), label='Original')
axes[2,1].plot(bjds[700][1:],np.fft.irfft(Yhat1c[:,700]), alpha=0.5, label='PCA-Filtered')
axes[2,1].yaxis.tick_right()
axes[2,1].yaxis.set_label_position("right")
axes[2,1].set_ylabel('Standardized Flux', rotation=-90, fontsize=12)
axes[2,1].legend(fontsize=12)

axes[3,1].plot(bjds[800][1:],np.fft.irfft(y[:,800]), label='Original')
axes[3,1].plot(bjds[800][1:],np.fft.irfft(Yhat1c[:,800]), alpha=0.5, label='PCA-Filtered')
axes[3,1].yaxis.tick_right()
axes[3,1].yaxis.set_label_position("right")
axes[3,1].set_ylabel('Standardized Flux', rotation=-90, fontsize=12)
axes[3,1].legend(fontsize=12)

axes[4,1].plot(bjds[900][1:],np.fft.irfft(y[:,900]), label='Original')
axes[4,1].plot(bjds[900][1:],np.fft.irfft(Yhat1c[:,900]), alpha=0.5, label='PCA-Filtered')
axes[4,1].yaxis.tick_right()
axes[4,1].yaxis.set_label_position("right")
axes[4,1].set_ylabel('Standardized Flux', rotation=-90, fontsize=12)
axes[4,1].set_xlabel('BJD - 2454833 (days)', fontsize=12)
axes[4,1].legend(fontsize=12)

plt.savefig('lc_detrend.png', dpi=100, bbox_inches='tight')

for i in range(100,900,200):

  fig = plt.figure(figsize=(10,5))

  res = np.fft.irfft(y[:,i]) - np.fft.irfft(Yhat1c[:,0])

  left, width = 0.1, 0.65
  bottom, height = 0.1, 0.65
  #bottom_h = left_h = left + width

  rect_scatter = [left, bottom + 0.2, width, height]
  rect_histx = [left, bottom, width, 0.2]
  #    rect_histy = [left_h, bottom, 0.2, height]
  plt.subplots_adjust(hspace=0., wspace=0.1)
  ax1 = plt.axes(rect_scatter)
  axres = plt.axes(rect_histx)
  ax1.minorticks_on()
  axres.minorticks_on()
  plt.setp(ax1.get_xticklabels(),
            visible=False)

  ax1.plot(bjds[i][1:], np.fft.irfft(y[:,i]), color='SteelBlue', alpha=0.5,
                                  label='Original')
  ax1.plot(bjds[i][1:], np.fft.irfft(Yhat1c[:,i]),
                                 color='DarkOrange', alpha=0.5,
                                  label='Filtered')
  ax1.set_ylabel('Standarized Flux')
  ax1.legend(fontsize=12)

  axres.errorbar(bjds[i][1:], res, yerr=None, color='k',
                               alpha=0.1, fmt='.')
  axres.set_xlabel('BJD - 2454833 (days)')
  axres.set_ylabel('Residuals')
  plt.show()

"""# Investigating TOIs

## Check periodicity
"""

!pip install PyAstronomy

from PyAstronomy.pyasl import foldAt

period = 0.2185
dur = np.nanmax(time1) - np.nanmin(time1)

# Obtain the phases with respect to some
# reference point 
phases = foldAt(time1[1:], period, T0=np.nanmin(time1))

# Sort with respect to phase
# First, get the order of indices ...
sortIndi = np.argsort(phases)
# ... and, second, rearrange the arrays.
phases = phases[sortIndi]
# Plot the result


plt.plot(phases-0.5, flux1norm[sortIndi], 'k.')
plt.plot(phases+0.5, flux1norm[sortIndi], 'k.')
#plt.plot(p-0.5, quadfit, c='cyan')
#plt.plot(p+0.5, quadfit, c='cyan')
plt.xlabel('Phase')
plt.ylabel('Standardized Flux')
plt.title('Phase-Folded (Raw)')
#plt.xlim(-0.5,1.5)
#plt.ylim(-0.1,0.1)
plt.savefig('phasefold1.png',dpi=100,bbox_inches='tight')
plt.show()

plt.plot(phases-0.5, Filtered_signal1[sortIndi], 'k.')
plt.plot(phases+0.5, Filtered_signal1[sortIndi], 'k.')
plt.xlabel('Phase')
plt.ylabel('Standardized Flux')
plt.title('Phase-Folded (PCA-Filtered)')
#plt.xlim(-0.5,1.5)
#plt.ylim(-0.1,0.1)
plt.savefig('phasefold2.png',dpi=100,bbox_inches='tight')
plt.show()

"""## Model flares"""

flares = [2253.65107,
          2240.04075,
          2281.57290,
          2284.68258,
          2287.91009,
          2268.87127,
          2295.39965,
          2299.37770,
          2291.45770,
          2248.59421,
          2261.51045,
          2269.02792,
          2249.17243,
          2276.02709,
          2229.08574,
          2293.30131,
          2295.02575,
          2258.54786,
          2284.92844,
          2238.85706,
          2251.42265,
          2249.41148,
         ]

len(flares)

fig, axes = plt.subplots(22, figsize=(10,60))

for i,flare in enumerate(flares):
  axes[i].scatter(time1, Filtered_signal1, color='k', marker='.', s=5)
  axes[i].vlines(flare, -50, 50, color='k', ls='--', alpha=0.25, label=str(flare))
  #axes[i].vlines(flare+(1./72), -50, 50, color='k', ls='--', alpha=0.75)
  #axes[i].vlines(flare-(1./96), -50, 50, color='k', ls='--', alpha=0.75)
  axes[i].set_xlim(flare-0.1,flare+0.1)
  axes[i].set_ylim(0.9,1.5)
  axes[i].set_ylabel('Rel. Flux')
  axes[i].legend()
plt.xlabel('BJD', fontsize=12)
plt.savefig('flares.png', bbox_inches='tight')
plt.show()

"""## Gabor Filtering"""

from skimage.filters import gabor

def gabor1D(x, Lambda, sigma=1, nstds=3, offset=0):

  gb = np.exp(-.5 * (x ** 2 / sigma ** 2)) * np.cos(2 * np.pi / Lambda * x + offset)

  return gb

i=1
x = np.arange(-50,50)
while i <= 32:
  print('Lambda = {}'.format(i))
  plt.plot(gabor1D(x, Lambda=i, sigma=8, nstds=10))
  plt.show()
  i *= 2

plt.plot(gabor1D(x, 2, sigma=5, nstds=5))
plt.savefig('gabor.png', dpi=100)

plt.plot(time2[1:], Filtered_signal2)

peakind = np.where(Filtered_signal2==Filtered_signal2.max())[0][0]

plt.plot(time2[1:][peakind-50:peakind+50], Filtered_signal2[peakind-50:peakind+50])

@interact
def gfiltergame(l=widgets.FloatSlider(min=0.1, max=10, step=0.1, value=2),
                s=widgets.FloatSlider(min=0.1, max=10, step=0.1, value=5),
                a=widgets.FloatSlider(min=1, max=50, step=1, value=30),
                offset1 = widgets.IntSlider(min=0, max=10, step=1, value=0),
                offset2 = widgets.IntSlider(min=0, max=10, step=1, value=1)):
  
  n=10
  y = Filtered_signal2[peakind-50:peakind+50]
  x = np.arange(-len(y)/2,len(y)/2)

  gabor1 = -a*gabor1D(x, Lambda = l, sigma=s, nstds=n)
  gabor2 = -a*gabor1D(x, Lambda = l, sigma=s, nstds=n)

  gabor = np.concatenate((gabor1[offset1:int(len(y)/2)], np.zeros(offset1), np.zeros(offset2), gabor2[int(len(y)/2):len(y)-offset2]))

  '''
  plt.plot(x, gabor1[offset1:int(len(y)/2)], label='Gabor1')
  plt.plot(x, gabor2[int(len(y)/2):-offset2], label='Gabor2')
  plt.plot(x, y, alpha=0.5, label='Ringing')
  plt.vlines(0,-200,200, alpha=0.5, ls='--')
  plt.legend()
  plt.show()
  '''
  plt.plot(x,y, label='Data')
  plt.legend()
  plt.show()

  plt.plot(x,y - gabor, color='r', label='Result')
  plt.vlines(0,-200,200, alpha=0.5, ls='--')
  plt.ylim(-50,300)
  plt.legend();

a = 30
s = 5
l = 2
offset1_true = 0 
offset2_true = 1 
n=10

y = Filtered_signal2[peakind-50:peakind+50]
x = np.arange(-len(y)/2,len(y)/2)

def gmodel(x,a,s,l):

  n=10

  gabor1 = -a*gabor1D(x, Lambda = l, sigma=s, nstds=n)
  gabor2 = -a*gabor1D(x, Lambda = l, sigma=s, nstds=n)
  gabor = np.concatenate((gabor1[offset1_true:int(len(y)/2)], np.zeros(offset1_true), 
                          np.zeros(offset2_true), gabor2[int(len(y)/2):len(y)-offset2_true]))

  return gabor

yred = y - gmodel(x,a,s,l)
np.where(yred == yred.max())[0][0]

flrmask = np.ones_like(yred, dtype='bool')
mask_l = 48
mask_r = 52
flrmask[mask_l:mask_r] = False

fig, ax = plt.subplots(1,3, figsize=(15,5))
ax[0].plot(yred)
ax[1].plot(yred[~flrmask])
ax[2].plot(yred[flrmask])

ax[0].set_ylim(-50,300)
ax[1].set_xlim(-50,50)
ax[1].set_ylim(-50,300)
ax[2].set_ylim(-50,300);

"""## Gabor Optimization"""

!pip install emcee

!pip install corner

import emcee
from scipy.optimize import minimize

offset_fctr = 1e-4

a_true = 30
s_true = 5
l_true = 2
m_true = np.mean(y[:30])
offset1_true = 0 * offset_fctr
offset2_true = 1 * offset_fctr

n=10

def gmodel(x,a,s,l,offset1,offset2):

  n=10
  #print(int(offset1 / offset_fctr), int(offset2 / offset_fctr))
  gabor1 = -a*gabor1D(x, Lambda = l, sigma=s, nstds=n)
  gabor2 = -a*gabor1D(x, Lambda = l, sigma=s, nstds=n)
  gabor = np.concatenate((gabor1[int(offset1 / offset_fctr):int(len(y)/2)], 
                          np.zeros(int(offset1 / offset_fctr)), 
                          np.zeros(int(offset2 / offset_fctr)), 
                          gabor2[int(len(y)/2):len(y)-int(offset2 / offset_fctr)]))
  return gabor

y = Filtered_signal2[peakind-50:peakind+50]
x = np.arange(-len(y)/2,len(y)/2)

def log_likelihood(theta, x, y):
    if len(theta) == 4:
      a,s,l,m = theta
      offset1 = offset1_true
      offset2 = offset2_true
    if len(theta) == 6:
      a, s, l, m, offset1, offset2 = theta

    model = gmodel(x,a,s,l,offset1,offset2)
    yred = y - model
    pred = np.zeros_like(yred)[flrmask] + m # put NaNs in here @ flare
    return -0.5 * np.nansum((yred[flrmask] - pred) ** 2)

nll = lambda *args: -log_likelihood(*args)
initial = np.array([a_true, s_true, l_true, m_true]) + 0.1 * np.random.randn(4)
soln = minimize(nll, initial, args=(x, y))
a_ml, s_ml, l_ml, m_ml = soln.x

print("Maximum likelihood estimates:")
print("a = {0:.3f}".format(a_ml))
print("s = {0:.3f}".format(s_ml))
print("l = {0:.3f}".format(l_ml))
print("m = {0:.3f}".format(m_ml))

def log_prior(theta):
    a, s, l, m, offset1, offset2 = theta
    if 0.0 < a < 50.0 and 0.0 < s < 10.0 and 0.0 < l < 20.0 and 0.0 < m < 5.0 \
    and int(0) < offset1 < (10 * offset_fctr) and int(0) < offset2 < (10 * offset_fctr):
        return 0.0
    return -np.inf

def log_probability(theta, x, y):
    lp = log_prior(theta)
    if not np.isfinite(lp):
        return -np.inf
    return lp + log_likelihood(theta, x, y)

soln6 = np.append(soln.x, [offset1_true, offset2_true])

###MCMC
pos = soln6 + 1e-3 * np.random.randn(128, 6)
nwalkers, ndim = pos.shape
sampler = emcee.EnsembleSampler(nwalkers, ndim, log_probability, args=(x, y))
sampler.run_mcmc(pos, 5000, progress=True);

fig, axes = plt.subplots(6, figsize=(10, 7), sharex=True)
samples = sampler.get_chain()
labels = ["a", "s", "l", "m", "offset1", "offset2"]
for i in range(ndim):
    ax = axes[i]
    ax.plot(samples[:, :, i], "k", alpha=0.3)
    ax.set_xlim(0, len(samples))
    ax.set_ylabel(labels[i])
    ax.yaxis.set_label_coords(-0.1, 0.5)

axes[-1].set_xlabel("step number");

flat_samples = sampler.get_chain(discard=100, thin=15, flat=True)
print(flat_samples.shape)

flat_samples[:,4:] /= offset_fctr

import corner

fig = corner.corner(
    flat_samples, labels=labels, truths=[a_ml, s_ml, l_ml, m_ml, offset1_true / offset_fctr, offset2_true / offset_fctr]
)

axes = np.array(fig.axes).reshape((6, 6))

for ax in fig.get_axes():
  ax.xaxis.label.set_size(24)
  ax.yaxis.label.set_size(24)

plt.savefig('gabor_corner.png', dpi=100, bbox_inches='tight')

from IPython.display import display, Math

for i in range(ndim):
    mcmc = np.percentile(flat_samples[:, i], [16, 50, 84])
    q = np.diff(mcmc)
    txt = "\mathrm{{{3}}} = {0:.3f}_{{-{1:.3f}}}^{{{2:.3f}}}"
    if "offset" in labels[i]:
      txt = txt.format(mcmc[1], q[0], q[1], labels[i])
    else:
      txt = txt.format(mcmc[1], q[0], q[1], labels[i])
    display(Math(txt))

a_fit = np.percentile(flat_samples[:, 0], 50)
s_fit = np.percentile(flat_samples[:, 1], 50)
l_fit = np.percentile(flat_samples[:, 2], 50)
m_fit = np.percentile(flat_samples[:, 3], 50)
off1_fit = np.percentile(flat_samples[:, 4], 50)
off2_fit = np.percentile(flat_samples[:, 5], 50)

y = Filtered_signal2[peakind-50:peakind+50]
x = np.arange(-len(y)/2,len(y)/2)

fig, ax = plt.subplots(1,2, figsize=(10,5))
ax[0].plot(x, yred)
ax[1].plot(x, y - gmodel(x, a_fit, s_fit, l_fit, offset1_true, offset2_true))
ax[1].plot(x, y - gmodel(x, a_fit, s_fit, l_fit, off1_fit * offset_fctr, off2_fit * offset_fctr))

ax[0].vlines(mask_l-50,-300,300, color='k', ls='--', alpha=0.5)
ax[0].vlines(mask_r-50,-300,300, color='k', ls='--', alpha=0.5)

ax[1].vlines(mask_l-50,-300,300, color='k', ls='--', alpha=0.5)
ax[1].vlines(mask_r-50,-300,300, color='k', ls='--', alpha=0.5)

ax[0].set_ylim(-100,300)
ax[1].set_ylim(-100,300)

ax[0].set_title('By Eye')
ax[1].set_title('MCMC');

y = Filtered_signal2[peakind-50:peakind+50]
x = np.arange(-len(y)/2,len(y)/2)

fig, ax = plt.subplots(1,2, figsize=(10,5))
ax[0].plot(x, y, color='k')
ax[1].plot(x, y - gmodel(x, a_fit, s_fit, l_fit, off1_fit * offset_fctr, off2_fit * offset_fctr), color='k')

flrtime = 2454833 - time2[peakind]

ax[0].set_title('Ringing')
ax[0].set_xlabel('BJD - {0:.3f} (days)'.format(flrtime))
ax[0].set_ylabel('Standardized Flux')
ax[0].set_ylim(-75,300)


ax[1].set_title('Gabor-Filtered Ringing')
ax[1].set_yticks([])
ax[1].set_xlabel('BJD - {0:.3f} (days)'.format(flrtime))
ax[1].set_ylim(-75,300)

plt.savefig('mcmc_comp.png', dpi=100, bbox_inches='tight')

2454833 - time2[peakind]

"""### Automating MCMC"""

len(time2[1:]) / ( time2[1:].max() - time2[1:].min() )

plt.plot(time2[1:], Filtered_signal2)

nl = 64920
nu = nl + 100
plt.plot(time2[1:][nl:nu], Filtered_signal2[nl:nu])

p2 = np.where(Filtered_signal2 == Filtered_signal2[nl:nu].max())[0][0]

flare = Filtered_signal2[p2-50:p2+50]
plt.plot(flare);

mask_l = 50
mask_r = 52

flrmask = np.ones_like(yred, dtype='bool')
flrmask[mask_l:mask_r] = False

fig, ax = plt.subplots(1,3, figsize=(15,5))
ax[0].plot(x,flare)
ax[1].plot(x[flrmask],flare[flrmask])
ax[2].plot(x[~flrmask],flare[~flrmask])

ax[0].set_xlim(-50,50)
ax[1].set_xlim(-50,50)
ax[2].set_xlim(-50,50)

ax[0].set_ylim(-50,200)
ax[1].set_ylim(-50,200)
ax[2].set_ylim(-50,200);

@interact
def gfiltergame(l=widgets.FloatSlider(min=0.1, max=10, step=0.1, value=2),
                s=widgets.FloatSlider(min=0.1, max=10, step=0.1, value=5),
                a=widgets.FloatSlider(min=1, max=50, step=1, value=15),
                offset1 = widgets.IntSlider(min=0, max=10, step=1, value=1),
                offset2 = widgets.IntSlider(min=0, max=10, step=1, value=2)):
  
  n=10
  y = flare
  x = np.arange(-len(y)/2,len(y)/2)

  gabor1 = -a*gabor1D(x, Lambda = l, sigma=s, nstds=n)
  gabor2 = -a*gabor1D(x, Lambda = l, sigma=s, nstds=n)

  gabor = np.concatenate((gabor1[offset1:int(len(y)/2)], np.zeros(offset1), np.zeros(offset2), gabor2[int(len(y)/2):len(y)-offset2]))


  plt.plot(x, gabor, label='Gabor')
  plt.plot(x, y, alpha=0.5, label='Ringing')
  plt.vlines(0,-200,200, ls='--')
  plt.fill_between((mask_l-50, mask_r-51), -200,200, alpha=0.2, label='mask')
  plt.xlim(-20,20)
  plt.ylim(-100,200)
  plt.legend()
  plt.show()
  
  plt.plot(x,y - gabor, color='r', label='Result')
  plt.fill_between((mask_l-50, mask_r-51), -200,200, alpha=0.2, label='mask')
  plt.vlines(0,-200,200, ls='--')
  plt.xlim(-20,20)
  plt.ylim(-100,200)
  plt.legend();

def auto_gabor_MCMC(flare, offset_factor, n, true_params, fix_offsets = ([0,0])):

  if len(true_params)==6:
    a_true, s_true, l_true, m_true, offset1_true, offset2_true = true_params
    offset1_true *= offset_factor
    offset2_true *= offset_factor
  if len(true_params)==4:
    a_true, s_true, l_true, m_true = true_params
    offset1_true = fix_offsets[0] * offset_factor
    offset2_true = fix_offsets[1] * offset_factor
  
  y = flare
  x = np.arange(-len(y)/2,len(y)/2)

  plt.plot(x,y)
  plt.fill_between((x[~flrmask].min(), x[~flrmask].max()),-500,500, alpha = 0.5, color='red')
  plt.ylim(-50,200)
  plt.title('Ringing')
  plt.show()

  def gmodel(x,a,s,l,offset1,offset2):
    
    gabor1 = -a*gabor1D(x, l, s, n)
    gabor2 = -a*gabor1D(x, l, s, n)
    gabor = np.concatenate((gabor1[int(offset1 / offset_factor):int(len(y)/2)], 
                          np.zeros(int(offset1 / offset_factor)), 
                          np.zeros(int(offset2 / offset_factor)), 
                          gabor2[int(len(y)/2):len(y)-int(offset2 / offset_factor)]))
    return gabor

  plt.plot(x, gmodel(x, a_true, s_true, l_true, offset1_true, offset2_true))
  plt.ylim(-50,200)
  plt.title('Filter')
  plt.show()

  def log_likelihood(theta, x, y):
    if len(theta) == 4:
      a,s,l,m = theta
      offset1 = offset1_true
      offset2 = offset2_true
    if len(theta) == 6:
      a, s, l, m, offset1, offset2 = theta

    model = gmodel(x,a,s,l,offset1,offset2)
    yred = y - model
    pred = np.zeros_like(yred)[flrmask] + m # put NaNs in here @ flare
    return -0.5 * np.nansum((yred[flrmask] - pred) ** 2)

  def log_prior(theta):
    if len(theta)==6:
      a, s, l, m, offset1, offset2 = theta
      if 0.0 < a < 50.0 and 0.0 < s < 10.0 and 0.0 < l < 20.0 and 0.0 < m < 5.0 \
      and int(0) < offset1 < (10 * offset_factor) and int(0) < offset2 < (10 * offset_factor):
        return 0.0

    if len(theta)==4:
      a, s, l, m = theta
      if 0.0 < a < 50.0 and 0.0 < s < 10.0 and 0.0 < l < 20.0 and 0.0 < m < 5.0:
        return 0.0
    return -np.inf

  def log_probability(theta, x, y):
    lp = log_prior(theta)
    if not np.isfinite(lp):
        return -np.inf
    return lp + log_likelihood(theta, x, y)

  pos = true_params + 1e-2 * np.random.randn(128, len(true_params))
  nwalkers, ndim = pos.shape
  sampler = emcee.EnsembleSampler(nwalkers, ndim, log_probability, args=(x, y))
  sampler.run_mcmc(pos, 5000, progress=True)

  fig, axes = plt.subplots(6, figsize=(10, 7), sharex=True)
  samples = sampler.get_chain()
  labels = ["a", "s", "l", "m", "offset1", "offset2"]

  for i in range(ndim):
    ax = axes[i]
    ax.plot(samples[:, :, i], "k", alpha=0.3)
    ax.set_xlim(0, len(samples))
    ax.set_ylabel(labels[i])
    ax.yaxis.set_label_coords(-0.1, 0.5)
  axes[-1].set_xlabel("step number");

  flat_samples = sampler.get_chain(discard=100, thin=15, flat=True)
  return flat_samples, ndim

np.array(x[~flrmask]+1, dtype=int)

guess = np.array([15, 5, 2, 1])
chain, ndim = auto_gabor_MCMC(flare, offset_factor=1e-4, n=10, true_params = guess, 
                              fix_offsets=([1,2]))

fig = corner.corner(chain, labels=labels, truths=guess)

axes = np.array(fig.axes).reshape((ndim,ndim))

for i in range(4):
    mcmc = np.percentile(chain[:, i], [16, 50, 84])
    q = np.diff(mcmc)
    txt = "\mathrm{{{3}}} = {0:.3f}_{{-{1:.3f}}}^{{{2:.3f}}}"
    if "offset" in labels[i]:
      txt = txt.format(mcmc[1], q[0], q[1], labels[i])
    else:
      txt = txt.format(mcmc[1], q[0], q[1], labels[i])
    display(Math(txt))

a_fit = np.percentile(chain[:, 0], 50)
s_fit = np.percentile(chain[:, 1], 50)
l_fit = np.percentile(chain[:, 2], 50)
m_fit = np.percentile(chain[:, 3], 50)

y = flare
x = np.arange(-len(y)/2,len(y)/2)

fig, ax = plt.subplots(1,2, figsize=(10,5))
ax[0].plot(x, y)
ax[0].plot(x, gmodel(x, a_fit, s_fit, l_fit, 1*1e-4,2*1e-4))
ax[1].plot(x, y - gmodel(x, a_fit, s_fit, l_fit, 1*1e-4,2*1e-4))
ax[0].set_ylim(-50,200)
ax[1].set_ylim(-50,200);

